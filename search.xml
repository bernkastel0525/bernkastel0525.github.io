<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STL常见容器和常用API</title>
      <link href="/2023/02/22/2023-2-22-STL%E5%B8%B8%E7%94%A8API/"/>
      <url>/2023/02/22/2023-2-22-STL%E5%B8%B8%E7%94%A8API/</url>
      
        <content type="html"><![CDATA[<h1 id="感觉总结的比较好的视频网址"><a href="#感觉总结的比较好的视频网址" class="headerlink" title="感觉总结的比较好的视频网址"></a>感觉总结的比较好的视频网址</h1><div class="tag link"><a class="link-card" title="STL" href="https://www.bilibili.com/video/BV1hb411j7mu/?p=19&spm_id_from=333.880.my_history.page.click"><div class="left"><img src="https://pic.imgdb.cn/item/63f61ef9f144a01007ba69cf.jpg"/></div><div class="right"><p class="text">STL</p><p class="url">https://www.bilibili.com/video/BV1hb411j7mu/?p=19&spm_id_from=333.880.my_history.page.click</p></div></a></div><h1 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h1><blockquote><p>查找find  复制copy  删除delete  替换replace  插入insert<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1.<span class="built_in">size</span>()<span class="comment">//s1的长度</span></span><br><span class="line">s1.<span class="built_in">at</span>(i)<span class="comment">//第i位s1的字符 相当于s1[i]</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">assign</span>(s2,<span class="type">int</span> x)<span class="comment">//把s2的前x个字符给s1</span></span><br><span class="line">s1.<span class="built_in">assign</span>(s2,<span class="type">int</span> pos,<span class="type">int</span> x)<span class="comment">//把s2从pos到（pos+x）的字符赋值给s1</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">aapend</span>(s2)<span class="comment">//将s2拼接到s1后面</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">find</span>(s2,<span class="type">int</span> x)<span class="comment">//从左往右，找不到s2则返回-1，找到返回第一次出现的位置</span></span><br><span class="line">默认x为<span class="number">0</span></span><br><span class="line">s1.<span class="built_in">rfind</span>(s2,<span class="type">int</span> x)<span class="comment">//从右往左，找不到s2则返回-1，找到返回第一次出现的位置</span></span><br><span class="line">默认x为s2.<span class="built_in">size</span>()</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">replace</span>(<span class="type">int</span> pos,<span class="type">int</span> x,s2)<span class="comment">//先删除从pos开始的x个字符</span></span><br><span class="line">再将s2从start开始插入</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">compare</span>(s2)<span class="comment">//若相等返回0 ，s1大于s2返回1，s1小于s2返回-1</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">substr</span>(<span class="type">int</span> pos,<span class="type">int</span> x)<span class="comment">//从s1的pos开始截取x个字符</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="type">int</span> pos,s2)<span class="comment">//将s2插入到pos的位置</span></span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="type">int</span> pos,<span class="type">int</span> x)<span class="comment">//从pos开始删除x个元素</span></span><br></pre></td></tr></table></figure></p></blockquote><hr><h1 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h1><blockquote><p>动态  支持随机访问  每次申请空间地址会变换</p><h2 id="1-构造"><a href="#1-构造" class="headerlink" title="1.构造"></a>1.构造</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt;v1 </span><br></pre></td></tr></table></figure><h2 id="2-vector迭代器"><a href="#2-vector迭代器" class="headerlink" title="2.vector迭代器"></a>2.vector迭代器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(vector&lt;<span class="type">int</span>&gt;::iterator it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();++it)</span><br><span class="line">                        cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">(vector&lt;<span class="type">int</span>&gt;::reverse_iterator it=v.<span class="built_in">rbegin</span>();it!=v.<span class="built_in">rend</span>();++it)</span><br><span class="line">                        cout&lt;&lt;*it&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="3-赋值操作"><a href="#3-赋值操作" class="headerlink" title="3.赋值操作"></a>3.赋值操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">v1</span>(<span class="type">int</span> x,<span class="type">int</span> n)<span class="comment">//将n个x拷贝到vector</span></span><br><span class="line"><span class="built_in">v1</span>(v2.<span class="built_in">begin</span>(),v2.<span class="built_in">end</span>())<span class="comment">//将v2中begin到end的元素拷贝给v1</span></span><br><span class="line">v1.<span class="built_in">assign</span>(v2.<span class="built_in">begin</span>(),v2.<span class="built_in">end</span>())<span class="comment">//赋值</span></span><br><span class="line">v1.<span class="built_in">swap</span>(v2)<span class="comment">//v1和v2交换  收缩内存 v.swap(v)</span></span><br></pre></td></tr></table></figure><h2 id="4-大小操作"><a href="#4-大小操作" class="headerlink" title="4.大小操作"></a>4.大小操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">size</span>()<span class="comment">//返回大小</span></span><br><span class="line">v1.<span class="built_in">empty</span>()<span class="comment">//是否为空</span></span><br><span class="line">v1.<span class="built_in">capacity</span>()<span class="comment">//容器容量</span></span><br><span class="line">v1.<span class="built_in">resize</span>(<span class="type">int</span> x，<span class="type">int</span> y)<span class="comment">//将容器重新指定长度 x，变长则以y(y可不填)填充，变短则删去</span></span><br><span class="line">v1.<span class="built_in">reserve</span>(<span class="type">int</span> len)<span class="comment">//预留len 个元素长度空间 不用每次寻找新地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-数据存取"><a href="#5-数据存取" class="headerlink" title="5.数据存取"></a>5.数据存取</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">at</span>()<span class="comment">//同string容器 operator[idx]</span></span><br><span class="line">v1.<span class="built_in">front</span>()<span class="comment">//返回第一个元素</span></span><br><span class="line">v1.<span class="built_in">back</span>()<span class="comment">//返回最后一个元素</span></span><br></pre></td></tr></table></figure><h2 id="6-插入与删除"><a href="#6-插入与删除" class="headerlink" title="6.插入与删除"></a>6.插入与删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">insert</span>(<span class="type">int</span> pos,<span class="type">int</span> n,<span class="type">int</span> x)<span class="comment">//在pos的位置插入n（k可不写默认为1）个x</span></span><br><span class="line">v1.<span class="built_in">push_back</span>(x)<span class="comment">//将x插入v1的尾部</span></span><br><span class="line">v1.<span class="built_in">pop_back</span>()<span class="comment">//尾部删除</span></span><br><span class="line">v1.<span class="built_in">erase</span>(<span class="type">int</span> pos1,<span class="type">int</span> pos2)<span class="comment">//删除pos1到pos2的元素，只写一个值就删一个</span></span><br><span class="line">v1.<span class="built_in">clear</span>()<span class="comment">//清空v1</span></span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><blockquote><p>双开口  双开口允许对头端进行删除和插入</p><h2 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1.构造"></a>1.构造</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque&lt;T&gt;d1</span><br></pre></td></tr></table></figure><h2 id="2-deque迭代器"><a href="#2-deque迭代器" class="headerlink" title="2.deque迭代器"></a>2.deque迭代器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(deque&lt;<span class="type">int</span>&gt;::iterator it=d.<span class="built_in">begin</span>();it!=d.<span class="built_in">end</span>();++it)</span><br></pre></td></tr></table></figure><h2 id="3-赋值操作-1"><a href="#3-赋值操作-1" class="headerlink" title="3.赋值操作"></a>3.赋值操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">d1</span>(<span class="type">int</span> x,<span class="type">int</span> n)将n个x拷贝到<span class="function">deque</span></span><br><span class="line"><span class="function"><span class="title">d1</span><span class="params">(d2.begin(),d2.end())</span><span class="comment">//将d2中begin到end的元素拷贝给d1</span></span></span><br><span class="line"><span class="function">d1.<span class="title">swap</span><span class="params">(d2)</span><span class="comment">//同vector</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><h2 id="4-大小操作-1"><a href="#4-大小操作-1" class="headerlink" title="4.大小操作"></a>4.大小操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d1.<span class="built_in">size</span>()</span><br><span class="line">d1.<span class="built_in">empty</span>()<span class="comment">//同vector</span></span><br><span class="line">d1.<span class="built_in">at</span>(i)</span><br><span class="line">d1.<span class="built_in">resize</span>(num,ele)<span class="comment">//重设容器长度num 过长则用ele填充</span></span><br></pre></td></tr></table></figure><h2 id="5-插入与删除"><a href="#5-插入与删除" class="headerlink" title="5.插入与删除"></a>5.插入与删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d1.<span class="built_in">push_back</span>(x)<span class="comment">//将x插入v1的尾部</span></span><br><span class="line">d1.<span class="built_in">pop_back</span>()<span class="comment">//尾部删除</span></span><br><span class="line">d1.<span class="built_in">front</span>(x)<span class="comment">//将x插入头部</span></span><br><span class="line">d1.pop_front<span class="comment">//在头部删除元素</span></span><br><span class="line">d1.<span class="built_in">insert</span>(<span class="type">int</span> pos,<span class="type">int</span> n,<span class="type">int</span> x)<span class="comment">//在pos的位置插入n（k可不写默认为1）个x</span></span><br><span class="line">d1.<span class="built_in">clear</span>()<span class="comment">//</span></span><br><span class="line">d1.<span class="built_in">erase</span>(<span class="type">int</span> pos1,<span class="type">int</span> pos2)<span class="comment">//删除pos1到pos2的元素，只写一个值就删一个</span></span><br></pre></td></tr></table></figure><h2 id="6-数据存取"><a href="#6-数据存取" class="headerlink" title="6.数据存取"></a>6.数据存取</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d1.<span class="built_in">at</span>(i)  <span class="comment">//operator[idx]</span></span><br><span class="line">d1.<span class="built_in">front</span>()</span><br><span class="line">d1.<span class="built_in">back</span>()</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h1><blockquote><p>栈 先进后出  不提供遍历没有迭代器<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;T&gt;s1<span class="comment">//构造</span></span><br><span class="line">s1.<span class="built_in">push</span>(x)<span class="comment">//x入栈</span></span><br><span class="line">s1.<span class="built_in">top</span>()<span class="comment">//返回栈顶元素</span></span><br><span class="line">s1.<span class="built_in">empty</span>()<span class="comment">//是否为空</span></span><br><span class="line">s1.<span class="built_in">pop</span>()<span class="comment">//弹出栈顶元素</span></span><br></pre></td></tr></table></figure></p></blockquote><hr><h1 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h1><blockquote><p>队列  先进先出 无迭代器不能遍历<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;T&gt;T<span class="comment">//构造</span></span><br><span class="line">q.<span class="built_in">push</span>(x)<span class="comment">//队尾加元素</span></span><br><span class="line">q.<span class="built_in">pop</span>()<span class="comment">//从队头移除第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>()<span class="comment">//返回最后一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>()<span class="comment">//返回第一个元素</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">empty</span>()<span class="comment">//判断为空‘</span></span><br><span class="line">q.<span class="built_in">size</span>()<span class="comment">//返回队列大小</span></span><br></pre></td></tr></table></figure></p></blockquote><hr><h1 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h1><blockquote><p>双向循环链表 非连续非顺序  构造list<T> T   </p><h2 id="1-list迭代器-不支持随机访问"><a href="#1-list迭代器-不支持随机访问" class="headerlink" title="1.list迭代器  不支持随机访问"></a>1.list迭代器  不支持随机访问</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(list&lt;<span class="type">int</span>&gt;::iterator it=l1.<span class="built_in">begin</span>();it!=l1.<span class="built_in">end</span>();++it)</span><br><span class="line">(list&lt;<span class="type">int</span>&gt;::reverse_iterator it=l1.<span class="built_in">rbegin</span>();it!=l1.<span class="built_in">rend</span>();++it)</span><br></pre></td></tr></table></figure><h2 id="2-插入与删除"><a href="#2-插入与删除" class="headerlink" title="2.插入与删除"></a>2.插入与删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">l1.<span class="built_in">push_back</span>(x)<span class="comment">//将x插入v1的尾部</span></span><br><span class="line">l1.<span class="built_in">pop_back</span>()<span class="comment">//尾部删除</span></span><br><span class="line">l1.<span class="built_in">front</span>(x)<span class="comment">//将x插入头部</span></span><br><span class="line">l1.<span class="built_in">pop_front</span>()<span class="comment">//在头部删除元素</span></span><br><span class="line">l1.<span class="built_in">insert</span>(<span class="type">int</span> pos,<span class="type">int</span> n,<span class="type">int</span> x)<span class="comment">//在pos的位置插入n（k可不写默认为1）个x</span></span><br><span class="line">l1.<span class="built_in">erase</span>(<span class="type">int</span> pos1,<span class="type">int</span> pos2)<span class="comment">//删除pos1到pos2的元素，只写一个值就删一个</span></span><br><span class="line">l1.<span class="built_in">clear</span>()<span class="comment">//清除</span></span><br><span class="line">l1.<span class="built_in">remove</span>(x)<span class="comment">//删除容器中所有与x值匹配的元素</span></span><br></pre></td></tr></table></figure><h2 id="3-大小操作"><a href="#3-大小操作" class="headerlink" title="3.大小操作"></a>3.大小操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">l1.<span class="built_in">size</span>()</span><br><span class="line">l1.<span class="built_in">empty</span>()</span><br><span class="line">l1.<span class="built_in">resize</span>(num,ele)<span class="comment">//重设容器长度num 过长则用ele填充</span></span><br></pre></td></tr></table></figure><h2 id="4-赋值操作"><a href="#4-赋值操作" class="headerlink" title="4.赋值操作"></a>4.赋值操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">l1.<span class="built_in">assign</span>(l2.<span class="built_in">begin</span>(),l2.<span class="built_in">end</span>())<span class="comment">//赋值</span></span><br><span class="line">l1.<span class="built_in">assign</span>(n,x)<span class="comment">//将n个x拷贝赋值给本身</span></span><br><span class="line">l1.<span class="built_in">swap</span>(l2)<span class="comment">//调换</span></span><br></pre></td></tr></table></figure><h2 id="5-数据存取-1"><a href="#5-数据存取-1" class="headerlink" title="5.数据存取"></a>5.数据存取</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">l1.<span class="built_in">front</span>()<span class="comment">//返回第一个</span></span><br><span class="line">l1.<span class="built_in">back</span>()<span class="comment">//返回第二个</span></span><br></pre></td></tr></table></figure><h2 id="6-反转排序"><a href="#6-反转排序" class="headerlink" title="6.反转排序"></a>6.反转排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">l1.<span class="built_in">reverse</span>()<span class="comment">//反转链表</span></span><br><span class="line">l1.<span class="built_in">sort</span>()<span class="comment">//排序 内部提供接口 </span></span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h1><blockquote><p>自动排序  不可以随便用迭代器改变值 构造 set<T> st   mulitset<T> mst</p><h2 id="1-set-multiset迭代器"><a href="#1-set-multiset迭代器" class="headerlink" title="1.set/multiset迭代器"></a>1.set/multiset迭代器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(set&lt;<span class="type">int</span>&gt;::iterator it=st.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();++i)</span><br></pre></td></tr></table></figure><h2 id="2-赋值操作"><a href="#2-赋值操作" class="headerlink" title="2.赋值操作"></a>2.赋值操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st1.<span class="built_in">swap</span>(st2)</span><br></pre></td></tr></table></figure><h2 id="3-大小操作-1"><a href="#3-大小操作-1" class="headerlink" title="3.大小操作"></a>3.大小操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st1.<span class="built_in">size</span>()</span><br><span class="line">st1.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><h2 id="4-插入和删除操作"><a href="#4-插入和删除操作" class="headerlink" title="4.插入和删除操作"></a>4.插入和删除操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st1.<span class="built_in">insert</span>(x)<span class="comment">//插入x</span></span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line">st1.<span class="built_in">erase</span>(pos)<span class="comment">//删除pos迭代器所指元素</span></span><br><span class="line">st1.<span class="built_in">erase</span>(st2.<span class="built_in">begin</span>(),st2.<span class="built_in">end</span>())<span class="comment">//删除区间[g=begin,end)元素并返回下元素迭代器</span></span><br><span class="line">st1.<span class="built_in">erase</span>(x)<span class="comment">//删除x元素</span></span><br></pre></td></tr></table></figure><h2 id="5-查找"><a href="#5-查找" class="headerlink" title="5.查找"></a>5.查找</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st1.<span class="built_in">find</span>(key)<span class="comment">//查看k是否存在,返回该键的元素的迭代器，不存在返回set,end()</span></span><br><span class="line">st1.<span class="built_in">count</span>(key)<span class="comment">//查找键key的元素个数</span></span><br><span class="line">st1.<span class="built_in">lower_bound</span>(keyElem)<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器</span></span><br><span class="line">st1.<span class="built_in">upper_bound</span>(keyElem)<span class="comment">//返回第一个key&gt;keyElem元素的迭代器</span></span><br><span class="line">st1.<span class="built_in">equal_range</span>(keyElem)<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器</span></span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h1><h2 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it=mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();++i)</span><br></pre></td></tr></table></figure><h2 id="2-构造"><a href="#2-构造" class="headerlink" title="2.构造"></a>2.构造</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;T1,T2&gt;mp1<span class="comment">//map默认构造</span></span><br><span class="line"><span class="built_in">map</span>(<span class="type">const</span> map &amp;mp1)<span class="comment">//拷贝构造</span></span><br></pre></td></tr></table></figure><h2 id="3-赋值"><a href="#3-赋值" class="headerlink" title="3.赋值"></a>3.赋值</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map&amp;mp)<span class="comment">//重载符号操作</span></span><br><span class="line">mp1.<span class="built_in">swap</span>(mp2)<span class="comment">//交换</span></span><br></pre></td></tr></table></figure><h2 id="4-大小操作-2"><a href="#4-大小操作-2" class="headerlink" title="4.大小操作"></a>4.大小操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp1.<span class="built_in">size</span>()</span><br><span class="line">mp1.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><h2 id="5-插入元素"><a href="#5-插入元素" class="headerlink" title="5.插入元素"></a>5.插入元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp1.<span class="built_in">insert</span>(..)<span class="comment">//往容器中插入元素。返回pair&lt;iterator,bool;&gt;</span></span><br><span class="line">map&lt;<span class="type">int</span> ,string&gt; mapStu</span><br><span class="line"><span class="comment">//pair方式插入对象</span></span><br><span class="line"><span class="function">mapStu <span class="title">insert</span><span class="params">(pair&lt;<span class="type">int</span> ,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>))</span></span></span><br><span class="line"><span class="function"><span class="comment">//pair方式插入对象  </span></span></span><br><span class="line"><span class="function">mapStu <span class="title">insert</span><span class="params">(make_pair(<span class="number">-1</span>,<span class="string">&quot;校长&quot;</span>))</span></span></span><br><span class="line"><span class="function"><span class="comment">//value_type方式插入</span></span></span><br><span class="line"><span class="function">mapStu <span class="title">insert</span><span class="params">(map&lt;<span class="type">int</span> ,string&gt;::value_type(<span class="number">1</span>,<span class="string">&quot;小李&quot;</span>))</span></span></span><br><span class="line"><span class="function"><span class="comment">//数组方式插入</span></span></span><br><span class="line"><span class="function">mapStu[3]</span>=<span class="string">&quot;小刘&quot;</span>  mapStu[<span class="number">5</span>]=<span class="string">&quot;小王&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-删除操作"><a href="#6-删除操作" class="headerlink" title="6.删除操作"></a>6.删除操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp1.<span class="built_in">clear</span>()<span class="comment">//删除所有操作</span></span><br><span class="line">mp1.<span class="built_in">erase</span>(pos)<span class="comment">//删除pos迭代器所指元素,返回下一个元素的迭代器</span></span><br><span class="line">mp1.<span class="built_in">erase</span>(beg,end)<span class="comment">//删除区间，返回下一个元素迭代器</span></span><br><span class="line">mp1.<span class="built_in">erase</span>(keyElem)<span class="comment">//删除容器中key为keyElem的对组</span></span><br></pre></td></tr></table></figure><h2 id="7-查找"><a href="#7-查找" class="headerlink" title="7.查找"></a>7.查找</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp1.<span class="built_in">find</span>(key)<span class="comment">//查找key是否存在</span></span><br><span class="line">mp1.<span class="built_in">count</span>(keyElem)<span class="comment">//返回容器中key为keyElem的对组个数，map 0和1  multimap 可能大于1</span></span><br><span class="line">mp1.<span class="built_in">lower_bound</span>(keyElem)<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器</span></span><br><span class="line">mp1.<span class="built_in">upper_bound</span>(keyElem)<span class="comment">//返回第一个key&gt;keyElem元素的迭代器</span></span><br><span class="line">mp1.<span class="built_in">equal_range</span>(keyElem)<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACwing 3956. 截断数组</title>
      <link href="/2023/02/21/2023-2-21-ACwing%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E6%88%AA%E6%96%AD%E6%95%B0%E7%BB%84/"/>
      <url>/2023/02/21/2023-2-21-ACwing%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E6%88%AA%E6%96%AD%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="3956-截断数组"><a href="#3956-截断数组" class="headerlink" title="3956. 截断数组"></a>3956. 截断数组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://pic.imgdb.cn/item/63f48412f144a0100743ca50.jpg" alt="题目"></p><hr><p><img src="https://pic.imgdb.cn/item/63f48650f144a010074711ac.jpg" alt="题目"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>首先特判一波，使数组分成3部分且相等，所以数组总和必为3的倍数</li><li>再者 随便给一刀当i，然后在i的左边找j ，j的范围<strong> 1到i-2 </strong> 而Sj=sum/3</li><li>然后Sn-Si-1这和第三部分 要等于 sum/3</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">s[i] += s[i - <span class="number">1</span>];<span class="comment">//计算前缀和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s[n] % <span class="number">3</span> != <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;<span class="comment">//特判</span></span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>,cnt=<span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i - <span class="number">2</span>] == s[n] / <span class="number">3</span>) cnt++; <span class="comment">//若第一部分符合说明这部个j符合 符合的个数j+1；</span></span><br><span class="line"><span class="keyword">if</span> (s[n] - s[i - <span class="number">1</span>] == s[n] / <span class="number">3</span>) res += cnt;<span class="comment">//若i也符合则测部分res+前面符合的j的个数</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 差分/前缀和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACwing 3729.改变数组元素</title>
      <link href="/2023/02/20/2023-2-20-ACwing%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/02/20/2023-2-20-ACwing%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="3729-改变数组元素"><a href="#3729-改变数组元素" class="headerlink" title="3729. 改变数组元素"></a>3729. 改变数组元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://pic.imgdb.cn/item/63f384eff144a010071488bc.jpg" alt="题目"><br><strong> 输入样例：</strong><br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">0 3 0 0 1 3</span><br><span class="line">10</span><br><span class="line">0 0 0 1 0 5 0 0 0 2</span><br><span class="line">3</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><br><strong> 输出样例：</strong><br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1 1 0 1 1 1</span><br><span class="line">0 1 1 1 1 1 0 0 1 1</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure></p><hr><p><img src="https://pic.imgdb.cn/item/63f385aef144a01007168f1d.jpg" alt="题解"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>要将空数组V的尾部加0，以及将位于数组 V 末尾的 ai 个元素都变为 1</li><li>设置当前V数组下标为i <font color=red>则i-ai+1到i</font> 这个区间内所有元素变1</li><li>相当于这个区间内的所有元素初始为0，在全部加1，这与<table><tr><td bgcolor=MistyRose>差分</td></tr></table>不谋而和</li><li>本题的差分，既可以使i前面所需区间变1，又可以使i后面加0</li><li>但是要注意如果ai超过V的大小，即变为 <font color=red>1到i</font> 的区间变1</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">memset</span>(b, <span class="number">0</span>, (n+<span class="number">1</span>)*<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">x = <span class="built_in">min</span>(x, i);<span class="comment">//x超出v的大小 把x更新为i</span></span><br><span class="line"><span class="type">int</span> l = i - x + <span class="number">1</span>, r = i;</span><br><span class="line">b[l]++, b[r + <span class="number">1</span>]--;<span class="comment">//差分模板  使一个范围内的数加上一个数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">b[i] += b[i - <span class="number">1</span>];<span class="comment">//差分数组前缀和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, !!b[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分思想"><a href="#差分思想" class="headerlink" title="差分思想"></a>差分思想</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">假设一个数组a[]为</span><br><span class="line"><span class="code">              0 0 0 0 0 0 0 0 0 </span></span><br><span class="line"><span class="code">下标为         </span></span><br><span class="line"><span class="code">              1 2 3 4 5 6 7 8 9 </span></span><br><span class="line"><span class="code">思考如何使区间3 4 5 6   的 0 变为 1 呢？</span></span><br><span class="line"><span class="code">很简单</span></span><br><span class="line"><span class="code">         即赋值a[3]=1   a[7]=-1</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">此时数组为     0 0 1 0 0 0 -1 0 0 </span><br><span class="line"></span><br><span class="line">然后利用前缀和 a[i]+=a[i-1]后即可变为</span><br><span class="line"><span class="code">              0 0 1 1 1 1  0 0 0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 差分/前缀和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C位域</title>
      <link href="/2022/12/27/C%E4%BD%8D%E5%9F%9F/"/>
      <url>/2022/12/27/C%E4%BD%8D%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="C-位域"><a href="#C-位域" class="headerlink" title="C 位域"></a>C 位域</h1><h2 id="位域概念"><a href="#位域概念" class="headerlink" title="位域概念"></a>位域概念</h2><p>如果程序的结构中包含多个开关量，只有 TRUE/FALSE 变量，如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> widthValidated;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> heightValidated;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure></p><hr><p>这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1。在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> widthValidated : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> heightValidated : <span class="number">1</span>;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure></p><hr><p>现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。让我们看看下面的实例来理解这个概念：</p><hr><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 定义简单的结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> widthValidated;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> heightValidated;</span><br><span class="line">&#125; status1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 定义位域结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> widthValidated : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> heightValidated : <span class="number">1</span>;</span><br><span class="line">&#125; status2;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Memory size occupied by status1 : %d\n&quot;</span>, <span class="keyword">sizeof</span>(status1));</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Memory size occupied by status2 : %d\n&quot;</span>, <span class="keyword">sizeof</span>(status2));</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Memory size occupied by status1 : <span class="number">8</span></span><br><span class="line">Memory size occupied by status2 : <span class="number">4</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="位域声明"><a href="#位域声明" class="headerlink" title="位域声明"></a>位域声明</h2><p>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为”位域”或”位段”。</p><p>所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p><p>典型的实例：</p><ul><li>用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。</li><li>读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</li></ul><h3 id="位域的定义和位域变量的说明"><a href="#位域的定义和位域变量的说明" class="headerlink" title="位域的定义和位域变量的说明"></a>位域的定义和位域变量的说明</h3><p>位域定义与结构定义相仿，其形式为：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 位域结构名 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"> 位域列表</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><p>其中位域列表的形式为：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type [member_name] : width ;</span><br></pre></td></tr></table></figure><br>下面是有关位域中变量元素的描述：<br><img src="https://pic.imgdb.cn/item/63aa7eab08b6830163405238.png" alt="指针"><br>带有预定义宽度的变量被称为位域。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> age : <span class="number">3</span>;</span><br><span class="line">&#125; Age;</span><br></pre></td></tr></table></figure><br>上面的结构定义指示 C 编译器，age 变量将只使用 3 位来存储这个值，如果您试图使用超过 3 位，则无法完成。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a:<span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> b:<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c:<span class="number">6</span>;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure><br>data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。<br>让我们再来看一个实例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packed_struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f1:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f2:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f3:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f4:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> my_int:<span class="number">9</span>;</span><br><span class="line">&#125; pack;</span><br></pre></td></tr></table></figure><br>在这里，packed_struct 包含了 6 个成员：四个 1 位的标识符 f1..f4、一个 4 位的 type 和一个 9 位的 my_int。<br>让我们来看下面的实例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> age : <span class="number">3</span>;</span><br><span class="line">&#125; Age;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   Age.age = <span class="number">4</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Sizeof( Age ) : %d\n&quot;</span>, <span class="keyword">sizeof</span>(Age) );</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Age.age : %d\n&quot;</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   Age.age = <span class="number">7</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Age.age : %d\n&quot;</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   Age.age = <span class="number">8</span>; <span class="comment">// 二进制表示为 1000 有四位，超出</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Age.age : %d\n&quot;</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当上面的代码被编译时，它会带有警告，当上面的代码被执行时，它会产生下列结果：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Sizeof( Age ) : <span class="number">4</span></span><br><span class="line">Age.age : <span class="number">4</span></span><br><span class="line">Age.age : <span class="number">7</span></span><br><span class="line">Age.age : <span class="number">0</span></span><br></pre></td></tr></table></figure><br><strong> 对于位域的定义尚有以下几点说明: </strong></p><ul><li>一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span>  :<span class="number">4</span>;    <span class="comment">/* 空域 */</span></span><br><span class="line">    <span class="type">unsigned</span> b:<span class="number">4</span>;    <span class="comment">/* 从下一单元开始存放 */</span></span><br><span class="line">    <span class="type">unsigned</span> c:<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。</li><li><p>位域的宽度不能超过它所依附的数据类型的长度，成员变量都是有类型的，这个类型限制了成员变量的最大长度，: 后面的数字不能超过这个长度。</p></li><li><p>位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>  :<span class="number">2</span>;    <span class="comment">/* 该 2 位不能使用 */</span></span><br><span class="line">    <span class="type">int</span> b:<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> c:<span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。</p></li></ul><h2 id="位域使用"><a href="#位域使用" class="headerlink" title="位域使用"></a>位域使用</h2><p>位域的使用和结构成员的使用相同，其一般形式为：</p><blockquote><p>位域变量名.位域名<br>位域变量名-&gt;位域名</p></blockquote><p>位域允许用各种格式输出。<br>请看下面的实例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> a:<span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> b:<span class="number">3</span>;</span><br><span class="line">        <span class="type">unsigned</span> c:<span class="number">4</span>;</span><br><span class="line">    &#125; bit,*pbit;</span><br><span class="line">    bit.a=<span class="number">1</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    bit.b=<span class="number">7</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    bit.c=<span class="number">15</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,bit.a,bit.b,bit.c);    <span class="comment">/* 以整型量格式输出三个域的内容 */</span></span><br><span class="line">    pbit=&amp;bit;    <span class="comment">/* 把位域变量 bit 的地址送给指针变量 pbit */</span></span><br><span class="line">    pbit-&gt;a=<span class="number">0</span>;    <span class="comment">/* 用指针方式给位域 a 重新赋值，赋为 0 */</span></span><br><span class="line">    pbit-&gt;b&amp;=<span class="number">3</span>;    <span class="comment">/* 使用了复合的位运算符 &quot;&amp;=&quot;，相当于：pbit-&gt;b=pbit-&gt;b&amp;3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&amp;011=011，十进制值为 3） */</span></span><br><span class="line">    pbit-&gt;c|=<span class="number">1</span>;    <span class="comment">/* 使用了复合位运算符&quot;|=&quot;，相当于：pbit-&gt;c=pbit-&gt;c|1，其结果为 15 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,pbit-&gt;a,pbit-&gt;b,pbit-&gt;c);    <span class="comment">/* 用指针方式输出了这三个域的值 */</span></span><br></pre></td></tr></table></figure><p>上例程序中定义了位域结构 bs，三个位域为 a、b、c。说明了 bs 类型的变量 bit 和指向 bs 类型的指针变量 pbit。这表示位域也是可以使用指针的。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
          <category> C语言位域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const与指针</title>
      <link href="/2022/12/16/%E6%B7%B1%E5%85%A5%E6%8C%87%E9%92%882/"/>
      <url>/2022/12/16/%E6%B7%B1%E5%85%A5%E6%8C%87%E9%92%882/</url>
      
        <content type="html"><![CDATA[<h1 id="简单理解const"><a href="#简单理解const" class="headerlink" title="简单理解const"></a>简单理解const</h1><h2 id="了解const限定符的用处与定义"><a href="#了解const限定符的用处与定义" class="headerlink" title="了解const限定符的用处与定义"></a>了解const限定符的用处与定义</h2><p><strong><em> const 在实际编程中用得并不多，const 是 constant 的缩写，意思是“恒定不变的”！它是定义只读变量的关键字，或者说 const 是定义常变量的关键字。 </em></strong><br><strong><em> const限定符的作用是告诉编译器这个被const限定的变量的值是不可被修改的，可以使用const限定符来实现“最小权限原则”。即给函数足够的权限，使其可以访问形参中的数据，已完成特定的功能。 </em></strong></p><hr><h2 id="const与指针连到一块该怎么看呢？"><a href="#const与指针连到一块该怎么看呢？" class="headerlink" title="const与指针连到一块该怎么看呢？"></a>const与指针连到一块该怎么看呢？</h2><p><font size = 5 color=red face="黑体">其实很简单只需要两步即可！</font><br><code>现在打开你的编译器</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="comment">// const int *p=&amp;a;</span></span><br><span class="line"><span class="comment">// int const *p=&amp;a;</span></span><br><span class="line"><span class="comment">// int *const p=&amp;a;</span></span><br><span class="line"><span class="comment">// const int *const p=&amp;a;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;a);<span class="comment">//变量地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p); <span class="comment">//变量地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;p);<span class="comment">//指针地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//变量值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>第一步定位const 向右查找所设的指针变量<font color=blue>*p</font>(注：p只是一个参数可以改变) </li><li>第二步如果右边第一个是<font color=blue>*</font>，则代表指针变量所指地址的值<code>不可改变</code>。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> *p=&amp;a;<span class="comment">//例如这个</span></span><br><span class="line">   <span class="type">int</span> <span class="type">const</span> *p=&amp;a;<span class="comment">//例如这个</span></span><br><span class="line"><span class="comment">// int *const p=&amp;a;</span></span><br><span class="line"><span class="comment">// const int *const p=&amp;a;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;a);<span class="comment">//变量地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p); <span class="comment">//变量地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;p);<span class="comment">//指针地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//变量值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果右边第一个是<font color=blue>p</font>，则指针变量所指地址<code>不可改变</code>。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="comment">// const int *p=&amp;a;</span></span><br><span class="line"><span class="comment">// int const *p=&amp;a;</span></span><br><span class="line">   <span class="type">int</span> *<span class="type">const</span> p=&amp;a;<span class="comment">//例如这个</span></span><br><span class="line"><span class="comment">// const int *const p=&amp;a;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;a);<span class="comment">//变量地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p); <span class="comment">//变量地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;p);<span class="comment">//指针地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//变量值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>但如果像下面这个所示呢？<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">const int <span class="emphasis">*const p=&amp;a;</span></span><br></pre></td></tr></table></figure>很简单和上面方法一样，先看第一个const，并向右寻找可以看到<font color=blue>*</font>在<font color=blue>p</font>的前方，则代表指针变量所指地址的值<code>不可改变</code>。<br>再看第二个const，并向右寻找可以看到第一个是<font color=blue>p</font>,则指针变量所指地址<code>不可改变</code>。<br>综上所述<br><font size = 5 color=red face="黑体">这样使用const可以使指针所指地址以及所指地址的值都不能被改变！</font><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="comment">// const int *p=&amp;a;</span></span><br><span class="line"><span class="comment">// int const *p=&amp;a;</span></span><br><span class="line"><span class="comment">// int *const p=&amp;a;</span></span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p=&amp;a;<span class="comment">//指针所指地址和所指地址的值都不能被改变</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;a);<span class="comment">//变量地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p); <span class="comment">//变量地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;p);<span class="comment">//指针地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//变量值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>只要这样看const和指针，便可以简单地解决掺杂在一起看不懂的问题！</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
          <category> C语言指针 </category>
          
          <category> const与指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决twikoo评论失败的办法-腾讯云域名</title>
      <link href="/2022/12/15/%E5%85%B3%E4%BA%8Etwikoo%E9%83%A8%E7%BD%B2%E5%88%B0vercel%E5%8D%B4%E8%AF%84%E8%AE%BA%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-%E8%85%BE%E8%AE%AF%E4%BA%91%E5%9F%9F%E5%90%8D/"/>
      <url>/2022/12/15/%E5%85%B3%E4%BA%8Etwikoo%E9%83%A8%E7%BD%B2%E5%88%B0vercel%E5%8D%B4%E8%AF%84%E8%AE%BA%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-%E8%85%BE%E8%AE%AF%E4%BA%91%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="解决twikoo评论失败的办法-腾讯云域名"><a href="#解决twikoo评论失败的办法-腾讯云域名" class="headerlink" title="解决twikoo评论失败的办法-腾讯云域名"></a>解决twikoo评论失败的办法-腾讯云域名</h1><h2 id="💥必须要提及的💥"><a href="#💥必须要提及的💥" class="headerlink" title="💥必须要提及的💥"></a>💥必须要提及的💥</h2><h3 id="1-本方法是基于唐志远大佬所提供的方法，基于-Hexo-键入评论功能twikoo"><a href="#1-本方法是基于唐志远大佬所提供的方法，基于-Hexo-键入评论功能twikoo" class="headerlink" title="1.本方法是基于唐志远大佬所提供的方法，基于 Hexo 键入评论功能twikoo"></a>1.本方法是基于唐志远大佬所提供的方法，基于 Hexo 键入评论功能twikoo</h3><p><code>详情请见</code><br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">https://tzy1997.com/articles/hexo1611/</span><br></pre></td></tr></table></figure></p><h3 id="2-解决方案是基于唐志远大佬的方案微改而成"><a href="#2-解决方案是基于唐志远大佬的方案微改而成" class="headerlink" title="2.解决方案是基于唐志远大佬的方案微改而成"></a>2.解决方案是基于唐志远大佬的方案微改而成</h3><p><code>详情请见</code><br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">tzy所用的是阿里云，可以跟着下面的链接走</span><br><span class="line">https://tzy1997.com/articles/hexo1614/</span><br><span class="line">对于完全的小白我所提供的是腾讯云的步骤</span><br></pre></td></tr></table></figure></p><hr><h2 id="🗨️为什么部署twikoo到vercel上却无法评论？"><a href="#🗨️为什么部署twikoo到vercel上却无法评论？" class="headerlink" title="🗨️为什么部署twikoo到vercel上却无法评论？"></a>🗨️为什么部署twikoo到vercel上却无法评论？</h2><p>由于 Vercel 官方域名的 Dns 问题，Twikoo 部署到vercel上无法获取评论数据。配置 twikoo 评论时，如果 envId 用了 vercel 自带的域名（类似 <a href="https://xxxxx.vercel.app/），则会遇到此问题。">https://xxxxx.vercel.app/），则会遇到此问题。</a><br>解决方案是用自定义的域名去代替 vercel 的域名，详情可参考 <a href="https://vercel.com/docs/concepts/projects/domains#dns-records">https://vercel.com/docs/concepts/projects/domains#dns-records</a> 。</p><hr><h2 id="❤️步骤"><a href="#❤️步骤" class="headerlink" title="❤️步骤"></a>❤️步骤</h2><h3 id="一-简单地购买一个腾讯云的域名"><a href="#一-简单地购买一个腾讯云的域名" class="headerlink" title="一.简单地购买一个腾讯云的域名"></a>一.简单地购买一个腾讯云的域名</h3><p><img src="https://pic.imgdb.cn/item/639add9fb1fccdcd365b65fb.png" alt="域名"></p><h3 id="二-创建二级域名"><a href="#二-创建二级域名" class="headerlink" title="二.创建二级域名"></a>二.创建二级域名</h3><blockquote><p>这里主要讲到添加二级域名的步骤，由于本人是阿里云的域名，因此以阿里云为示范。<br>我的一级域名是bernkastel.fun，二级域名twi.bernkastel.fun。这里的二级域名，名字(xxx.<br>bernkastel.fun)随便取即可。</p><ol><li>登录进入 腾讯云域名控制台 ，搜索域名。<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">https://console.dnspod.cn/dns/list</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/639addacb1fccdcd365b75c8.png" alt="域名"></li><li>在图所示的列表中，点击你刚购买的域名<br><img src="https://pic.imgdb.cn/item/639addb0b1fccdcd365b7ab1.png" alt="域名"></li><li>点击添加记录，如图所示填写，然后点击确认<br><img src="https://pic.imgdb.cn/item/639addb3b1fccdcd365b7f32.png" alt="域名"></li></ol></blockquote><h3 id="三-将二级域名解析到Vercel"><a href="#三-将二级域名解析到Vercel" class="headerlink" title="三.将二级域名解析到Vercel"></a>三.将二级域名解析到Vercel</h3><ol><li>点击右上方的三角形进入此页面<br><img src="https://pic.imgdb.cn/item/639add74b1fccdcd365b2e54.png" alt="域名"></li><li>点击你部署twikoo所用的仓库<br><img src="https://pic.imgdb.cn/item/639add7cb1fccdcd365b39fe.png" alt="域名"></li><li><p>进入左上角settings界面，然后再进入左侧Domains，最后add你刚刚添加的二级域名<br><img src="https://pic.imgdb.cn/item/639add99b1fccdcd365b5f0f.png" alt="域名"></p><h3 id="四-替换envid"><a href="#四-替换envid" class="headerlink" title="四.替换envid"></a>四.替换envid</h3><p>在主题配置文件<code>_config.butterfly.yml</code>中修改以下内容，将你的环境id填入对应位置</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"> # Twikoo</span><br><span class="line"><span class="section"># https://github.com/imaegoo/twikoo</span></span><br><span class="line">twikoo:</span><br><span class="line">  envId: https://twi.bernkastel.fun/ </span><br><span class="line">  region: </span><br><span class="line">  visitor: true</span><br><span class="line">  option:</span><br></pre></td></tr></table></figure><p>最后别忘了重新编译运行，运行之后即可看到效果。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客搭建常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蛇鲨狩猎-章节三</title>
      <link href="/2022/12/12/%E8%9B%87%E9%B2%A8%E7%8B%A9%E7%8C%8E-%E7%AB%A0%E8%8A%82%E4%B8%89/"/>
      <url>/2022/12/12/%E8%9B%87%E9%B2%A8%E7%8B%A9%E7%8C%8E-%E7%AB%A0%E8%8A%82%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="THE-BAKER’S-TALE"><a href="#THE-BAKER’S-TALE" class="headerlink" title="THE BAKER’S TALE"></a>THE BAKER’S TALE</h2><p>面包师的过去<br>They roused him with muffins—they roused him with ice— They<br>roused him with mustard and cress— They roused him with jam and<br>judicious advice— They set him conundrums to guess.<br>他们用松饼将其唤醒，他们用冰块试图冷敷，<br>他们甚至想把芹菜蘸着芥末塞进他的鼻子，<br>他们利用某人明智的建议用果酱甜他嘴巴，<br>最后试图出一些难题让他猜测！</p><p>When at length he sat up and was able to speak, His sad story he<br>offered to tell; And the Bellman cried “Silence! Not even a shriek!” And<br>excitedly tingled his bell.<br>最后他突然坐起并说起了话，他主动提出要讲述他悲惨过去。<br>于是敲铃人大喊“请大家肃静！  不要大喊大叫！”<br>接着敲铃人便敲起了他的大铃铛声音不绝于耳。</p><p>There was silence supreme! Not a shriek, not a scream, Scarcely even<br>a howl or a groan, As the man they called “Ho!” told his story of woe In an<br>antediluvian tone.<br>现在十分安静说为寂静也无不妥，没有敲铃人的大喊，没有小海狸的哀嚎，<br>这时候被称为“Ho”（他好像没名字）的面包师，用更古的语气讲述起了他的悲剧！</p><p>“My father and mother were honest, though poor—“ “Skip all that!”<br>cried the Bellman in haste. “If it once becomes dark, there’s no chance of a<br>Snark— We have hardly a minute to waste!”<br>“我有一个贫穷但诚实的父母，” “跳过这部分”敲钟人又急切大喊，<br> 船员用诧异的眼神盯着他，敲铃人对此却不在意的说<br>“天将近黄昏蛇鲨会睡觉，我们再不能浪费时间了。”</p><p>“I skip forty years,” said the Baker, in tears, “And proceed without<br>further remark To the day when you took me aboard of your ship To help<br>you in hunting the Snark.<br>“我会跳过四十年”面包师泪流满面，“直到你把我带上船去抓蛇鲨的那一天，<br>我就不会继续往下说了。”</p><p>“He remarked to me then,” said that mildest of men, “ ‘If your Snark be<br>a Snark, that is right: Fetch it home by all means—you may serve it with<br>greens, And it’s handy for striking a light.<br>“那时的他对我说啊：如果你的蛇鲨是蛇鲨，那可真是棒极了，定要千方百计把它带回家<br>记得带上绿叶子，用它点亮大火焰。”</p><p>“ ‘You may seek it with thimbles—and seek it with care; You may hunt<br>it with forks and hope; You may threaten its life with a railway-share; You<br>may charm it with smiles and soap—‘ “<br>“寻找它需要针眼与耐心，要用鱼叉使出希望一击，<br> 再用铁路股份威胁蛇鲨，最后微笑着拿肥皂勾引。”</p><p>(“That’s exactly the method,” the Bellman bold In a hasty parenthesis<br>cried, “That’s exactly the way I have always been told That the capture of<br>Snarks should be tried!”)<br>（”这正是那个好办法！”敲铃人用简单地括号喊道”<br> 这便是我听说的狩猎蛇鲨的好办法！）</p><p>“ ‘But oh, beamish nephew, beware of the day, If your Snark be a<br>Boojum! For then You will softly and suddenly vanish away, And never be<br>met with again!’<br>“但是，我可爱的侄子啊，当心捉到蛇鲨的那天吧<br> 如果捕捉到的是博基姆，你将默默地消失踪迹啊，再也不会重现人间！”</p><p>“It is this, it is this that oppresses my soul, When I think of my uncle’s<br>last words: And my heart is like nothing so much as a bowl Brimming<br>over with quivering curds!</p><p>“It is this, it is this—“ “We have had that before!” The Bellman<br>indignantly said. And the Baker replied “Let me say it once more. It is this,<br>it is this that I dread!</p><p>“I engage with the Snark—every night after dark— In a dreamy<br>delirious fight: I serve it with greens in those shadowy scenes, And I use it<br>for striking a light:</p><p>“But if ever I meet with a Boojum, that day, In a moment (of this I am<br>sure), I shall softly and suddenly vanish away— And the notion I cannot<br>endure!”</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
          <category> 蛇鲨狩猎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针的理解</title>
      <link href="/2022/12/12/%E6%B7%B1%E5%85%A5%E6%8C%87%E9%92%881/"/>
      <url>/2022/12/12/%E6%B7%B1%E5%85%A5%E6%8C%87%E9%92%881/</url>
      
        <content type="html"><![CDATA[<h1 id="关于指针个人的理解"><a href="#关于指针个人的理解" class="headerlink" title="关于指针个人的理解"></a>关于指针个人的理解</h1><h2 id="1-数据类型的引入"><a href="#1-数据类型的引入" class="headerlink" title="1.数据类型的引入"></a>1.数据类型的引入</h2><h3 id="用生活中的例子说明"><a href="#用生活中的例子说明" class="headerlink" title="用生活中的例子说明"></a>用生活中的例子说明</h3><p><table><tr><td bgcolor=MistyRose>简单地举个列子，小明想买个礼物，然后把礼物放进礼物盒；礼物有大的，也有小的，礼物盒也同样。因此小明要根据礼物大小`合  理`地选择礼物盒。小明可以把小发卡放进超大盒子，但这样却会造成空间浪费。为解决空间浪费小明一定会选择适合装发卡的礼物盒。</td></tr></table></p><hr><p>💥在C语言中也如此———如果把小的数据放进了大的数据类型中，则会造成内存的浪费。<br>平常我们AK题的时候为了省时省力，通常会将所有的浮点数据放进<font color=blue>double</font>而不是<font color=blue>float</font>，这样确实可以；<br>但是进行一些大型项目时，这样做的话，容易积少成多造成内存浪费，从而造成服务器性能下降 。<br>这时候我们必须合理的选项数据类型，优化项目代码。<br>我们便可以得出结论</p><p><font size = 5 color=red face="黑体">数据类型的本质作用就是合理地利用空间</font></p><hr><h2 id="2-基本数据类型举例"><a href="#2-基本数据类型举例" class="headerlink" title="2.基本数据类型举例"></a>2.基本数据类型举例</h2><p><font color=blue>char  int  long  float  double</font></p><p><font color=blue>char</font>  1字节   </p><p><font color=blue>int</font>  4字节<br>查看字节可以模仿下面的代码<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(char)=%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int)=%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/639addbab1fccdcd365b869c.png" alt="指针"><br><u><code>1B==8位b（二进制位</code></u><br><u><code>1b只能存放0或者1</code></u></p><hr><h2 id="3-指针与内存的关系"><a href="#3-指针与内存的关系" class="headerlink" title="3.指针与内存的关系"></a>3.指针与内存的关系</h2><p>内存的两个概念：物理存储器和存储地址空间<br>前者是实际存在的具体存储器芯片<br>后者是对存储器编码的范围</p><h3 id="P1．现实中的内存："><a href="#P1．现实中的内存：" class="headerlink" title="P1．现实中的内存："></a>P1．现实中的内存：</h3><p>1.快递的快递箱，箱子上都有编号，我们便可以根据编号找到快递<br>2.一栋楼的所有房间，房间都有房间号，我们便可以根据房间号找到相应房间</p><h3 id="P2．计算机内存的管理"><a href="#P2．计算机内存的管理" class="headerlink" title="P2．计算机内存的管理"></a>P2．计算机内存的管理</h3><p>将内存抽象成一个很大的一维字符数组<br>对内存中的每一个字节分配一个32位或64位的编号<br>这个编号我们称之为内存地址</p><h3 id="P3．指针变量"><a href="#P3．指针变量" class="headerlink" title="P3．指针变量"></a>P3．指针变量</h3><p>内存区的每一个字节都有一个编号，这就是<code>地址</code>。<br>指针的实质就是内存“地址”。<br>指针就是地址，地址就是指针<br>指针是内存单元的编号，指针变量是存放地址的变量<br><img src="https://pic.imgdb.cn/item/639addbdb1fccdcd365b8ab3.png" alt="指针"><br>编号（地址）：内存中每一个字节分配一个号码<br>定义一个变量 存放上面的号码 这样的变量叫做指针变量。</p><hr><h2 id="4-如何得到这个号码"><a href="#4-如何得到这个号码" class="headerlink" title="4.如何得到这个号码"></a>4.如何得到这个号码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> num=<span class="number">100</span>; <span class="comment">//取变量地址用&amp;</span></span><br><span class="line">   <span class="built_in">printf</span>(“%p\n”,&amp;num); <span class="comment">//&amp;num代表标量num的起始地址</span></span><br><span class="line"><span class="comment">//需求：定义一个指针变量 保存num的地址</span></span><br><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(p)=%d\n&quot;</span>,<span class="keyword">sizeof</span>(p));  <span class="comment">//结果为4</span></span><br><span class="line"><span class="comment">//num的地址与p建立关系</span></span><br><span class="line">p=&amp;num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num=%d\n&quot;</span>,num);</span><br><span class="line"><span class="comment">//使用中：*p表示取p保存的地址编号对应的空间内容</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">text3</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//指针变量的两种类型：自身类型  指向类型</span></span><br><span class="line"><span class="comment">//自身类型：指针变量定义的时候 将变量名拖黑，剩下啥类型，剩下啥类型指针变量就是啥类型  p自身类型为int *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指向类型：指针变量定义的时候，将变量名和离它最近的一个*拖黑，剩下啥类型，剩下啥类型，指针变量指向的类型就是啥类型 P指向类型是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量指向类型作用：决定了指针变量，所取空间内容宽度，决定了指针变量+1跳过的单位跨度</span></span><br><span class="line"><span class="type">int</span> *p = NULL;</span><br><span class="line">p =&amp;num;</span><br><span class="line"><span class="comment">//指针变量的跨度</span></span><br><span class="line">printf(<span class="string">&quot;&amp;num = % u\n&quot;</span>, &amp;num);</span><br><span class="line"><span class="comment">//536</span></span><br><span class="line">printf(<span class="string">&quot;p = % u\n&quot;</span>, p);</span><br><span class="line"><span class="comment">//536</span></span><br><span class="line">printf(<span class="string">&quot;p + 1 = % u\n&quot;</span>, p + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//540</span></span><br><span class="line"><span class="comment">//加1后跳过指向类型int 的单位跨度 4</span></span><br><span class="line"><span class="type">char</span> *p1 =&amp;num;</span><br><span class="line">printf(<span class="string">&quot;&amp;num = % u\n&quot;</span>, &amp;num);</span><br><span class="line"><span class="comment">//536</span></span><br><span class="line">printf(<span class="string">&quot;p1 = % u\n&quot;</span>, p1);</span><br><span class="line"><span class="comment">//536</span></span><br><span class="line">printf(<span class="string">&quot;p1 + 1 = % u\n&quot;</span>, p1 + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//537</span></span><br><span class="line"><span class="comment">//加1后跳过指向类型char的单位跨度 1</span></span><br><span class="line">printf(<span class="string">&quot;*p = % u\n&quot;</span>, *p);</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>自身类型：指针变量定义的时候 将变量名拖黑，剩下啥类型，剩下啥类型指针变量就是啥类型，p自身类型为int *</code><br><img src="https://pic.imgdb.cn/item/639addc4b1fccdcd365b92c3.png" alt="指针"><br><code>指向类型：指针变量定义的时候,将变量名和离它最近的一个*拖黑,剩下啥类型,剩下啥类型,指针变量指向的类型就是啥类型,P指向类型是int</code><br><img src="https://pic.imgdb.cn/item/639addc8b1fccdcd365b96e9.png" alt="指针"></p><hr><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">text4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> num=<span class="number">0x01020304</span>;<span class="comment">//倒着存倒着取</span></span><br><span class="line"> <span class="type">int</span> *p1=&amp; num;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;*p1=%#x\n&quot;</span>,*p1);<span class="comment">//取0x01020304</span></span><br><span class="line"> <span class="type">short</span> *p2=&amp; num;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;*p2=%#x\n&quot;</span>,*p2);<span class="comment">//取0x0304</span></span><br><span class="line"> <span class="type">char</span> *p3=&amp; num;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;*p3=%#x\n&quot;</span>,*p3);<span class="comment">//取0x04</span></span><br><span class="line"> <span class="type">short</span> *p4=&amp; num;</span><br><span class="line"> p4=p4+<span class="number">1</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;*p4=%#x\n&quot;</span>,*p4);<span class="comment">//取0x0102</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/639addc1b1fccdcd365b8e55.png" alt="指针"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
          <category> C语言指针 </category>
          
          <category> 数据类型和内存和指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蛇鲨狩猎-章节二</title>
      <link href="/2022/12/09/2022-12-8-%E8%9B%87%E9%B2%A8%E7%8B%A9%E7%8C%8E-%E7%AB%A0%E8%8A%82%E4%BA%8C/"/>
      <url>/2022/12/09/2022-12-8-%E8%9B%87%E9%B2%A8%E7%8B%A9%E7%8C%8E-%E7%AB%A0%E8%8A%82%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="THE-BELLMAN’S-SPEECH"><a href="#THE-BELLMAN’S-SPEECH" class="headerlink" title="THE BELLMAN’S SPEECH"></a>THE BELLMAN’S SPEECH</h2><p>敲铃人的演说<br>The Bellman himself they all praised to the skies— Such a carriage,<br>such ease and such grace! Such solemnity, too! One could see he was wise,<br>The moment one looked in his face!<br>他们把摇铃人吹捧上天！—他仪态华贵，气定神闲，<br>他动作优雅，不失庄严！—他十分聪明，从外表上知道这点!<br>He had bought a large map representing the sea, Without the least<br>vestige of land: And the crew were much pleased when they found it to be<br>A map they could all understand.<br>他买了一张代表海洋的大地图，简直一丁点陆地的痕迹都没有。<br>船员们十分兴奋，因为他们发现那是一张他们都能看懂的地图!<br>“What’s the good of Mercator’s North Poles and Equators, Tropics,<br>Zones, and Meridian Lines?” So the Bellman would cry: and the crew<br>would reply “They are merely conventional signs!<br>“墨卡托的地图烂透了 ， 所注的北极圈与赤道，<br> 画着经纬和北回归线 ， 等角航线和本初子午，<br> 尽是糟糕的东西！” ， 敲铃人如此大声高喊：<br> 船员们接着再次重复 ，”那就只是过时的传统!”<br>“Other maps are such shapes, with their islands and capes! But we’ve<br>got our brave Captain to thank: (So the crew would protest) “that he’s<br>bought us the best— A perfect and absolute blank!”<br>“其他的地图全是这种形状 ，携带着它们的岛屿与海角!<br> 我们要”感谢”这勇敢的船长：（所以船员们会抗议）<br> 他为我们买了张最“完美”的，一张完美而绝对的“空白”。<br>This was charming, no doubt; but they shortly found out That the<br>Captain they trusted so well Had only one notion for crossing the ocean,<br>And that was to tingle his bell.<br>那是毫无疑问的迷人 ， 但是他们很快就发现，<br>那位船长对航海十分了解—-那就是敲他的铃铛。<br>He was thoughtful and grave—but the orders he gave Were enough to<br>bewilder a crew. When he cried “Steer to starboard, but keep her head<br>larboard!” What on earth was the helmsman to do?<br>他思维缜密态度严肃，但下的指令却令人困惑。<br>当他喊着”转向右舷 ，但将船舵保持头部左舷！”<br>这时的舵手要如何是好？<br>Then the bowsprit got mixed with the rudder sometimes: A thing, as<br>the Bellman remarked, That frequently happens in tropical climes, When a<br>vessel is, so to speak, “snarked.”<br>然后船首斜桅有时会和舵混在一起：船长说道这种情况在热带地区经常发生<br>可以这么说船被“蛇鲨”了。<br>But the principal failing occurred in the sailing, And the Bellman,<br>perplexed and distressed, Said he had hoped, at least, when the wind blew<br>due East, That the ship would not travel due West!<br>但主要的失败发生在航行中，令敲铃人感到苦恼而又困惑，<br>他说至少我们还仍旧有希望—-当风吹过时正东，船不会正西行驶！<br>But the danger was past—they had landed at last, With their boxes,<br>portmanteaus, and bags: Yet at first sight the crew were not pleased with<br>the view, Which consisted to chasms and crags.<br>但是危险终将过去，他们带着行李着陆了，<br>但船员对眼前的景色并不满意：那里仅仅有峡谷和高山。<br>The Bellman perceived that their spirits were low, And repeated in<br>musical tone Some jokes he had kept for a season of woe— But the crew<br>would do nothing but groan.<br>敲铃人发现船员们情绪低落，就重复了一遍他在迷路时一直在讲的笑话，<br>但是大家们除了呻吟没有任何反应。<br>He served out some grog with a liberal hand, And bade them sit down<br>on the beach: And they could not but own that their Captain looked grand,<br>As he stood and delivered his speech.<br>敲铃人慷慨而又大方，将美食美酒分发船员，<br>然后让他们坐上沙滩，船员们啊，心中有怨，<br>却不得不承认啊，船长看上去的威严：<br>仅仅只有当他站起发言时的威严。<br>“Friends, Romans, and countrymen, lend me your ears!” (They were<br>all of them fond of quotations: So they drank to his health, and they gave<br>him three cheers, While he served out additional rations).<br>“我的亲友啊，同胞啊，以及罗马人啊！<br> 至少现在请求你们竖耳倾听我的讲话，<br>（他们都喜欢用这句话，之后的船员们痛饮三杯<br> 敲铃人甚至大发慈悲，给予了所有船员下酒菜）<br>“We have sailed many months, we have sailed many weeks, (Four<br>weeks to the month you may mark), But never as yet (‘tis your Captain<br>who speaks) Have we caught the least glimpse of a Snark!<br>“We have sailed many weeks, we have sailed many days, (Seven days<br>to the week I allow), But a Snark, on the which we might lovingly gaze,<br>We have never beheld till now!<br>“我们已航行了数个月，我们已航行了许多周，<br>（你可以认为一月为四周）<br> 但是我们不断拼命寻找的蛇鲨，从未出现！<br> 我们已航行了许多周，我们已航行了很多天，<br>（大概七天为一周）<br> 但是我们渴望深情凝视的蛇鲨，从未看见！<br>“Come, listen, my men, while I tell you again The five unmistakable<br>marks By which you may know, wheresoever you go, The warranted<br>genuine Snarks.<br>但是我所告知诸位的五个标记，绝对的正确，绝对的无差！<br>无论你去往何方，仅凭这五点，便可得知蛇鲨的有无！<br>“Let us take them in order. The first is the taste, Which is meager and<br>hollow, but crisp: Like a coat that is rather too tight in the waist, With a<br>flavor of Will-o-the-wisp.<br>先让我们排序好，第一肯定是味道，<br>这肉质卷却竖直，尝起来绝对奇妙，<br>空心瘦美而酥脆，像件紧身的外衣；</p><p>“Its habit of getting up late you’ll agree That it carries too far, when I<br>say That it frequently breakfasts at five-o’clock tea, And dines on the<br>following day.<br>第二是蛇鲨早睡晚起，你要尽快习惯这一点，<br>它吃午饭要拖到明天，它吃早饭在下午五点；</p><p>“The third is its slowness in taking a jest. Should you happen to<br>venture on one, It will sigh like a thing that is deeply distressed: And it<br>always looks grave at a pun.<br>第三要数它开玩笑时动作慢，你真的不该错过这搞笑时刻。<br>那时的样子就像在痛苦喘息，用双关语来说是严肃的表情。</p><p>“The fourth is its fondness for bathing-machines, Which is constantly<br>carries about, And believes that they add to the beauty of scenes— A<br>sentiment open to doubt.<br>第四啊它对洗澡万分执念，以至于到了珍惜洗澡的地步。<br>它相信这能使环境改善，我却怀疑这件事的真伪。</p><p>“The fifth is ambition. It next will be right To describe each particular<br>batch: Distinguishing those that have feathers, and bite, And those that<br>have whiskers, and scratch.<br>第五是它野心勃勃，在描述上万分细致。<br>能区分鸟类和爬行类，能判断爪痕与络腮胡。</p><p>“For, although common Snarks do no manner of harm, Yet, I feel it my<br>duty to say, Some are Boojums—“ The Bellman broke off in alarm, For the<br>Baker had fainted away.<br>“虽然蛇鲨十分无害，但是我仍旧会讲明<br> 有些不是蛇鲨而是博基姆（Boojums）”<br>敲铃人突兀地中断了演讲，因为面包师晕倒了过去。</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
          <category> 蛇鲨狩猎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蛇鲨狩猎-章节一</title>
      <link href="/2022/12/09/2022-12-8-%E8%9B%87%E9%B2%A8%E7%8B%A9%E7%8C%8E-%E7%AB%A0%E8%8A%82%E4%B8%80/"/>
      <url>/2022/12/09/2022-12-8-%E8%9B%87%E9%B2%A8%E7%8B%A9%E7%8C%8E-%E7%AB%A0%E8%8A%82%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="THE-LANDING"><a href="#THE-LANDING" class="headerlink" title="THE LANDING"></a>THE LANDING</h2><p>登 陆<br>“Just the place for a Snark!” the Bellman cried, As he landed his crew<br>with care; Supporting each man on the top of the tide By a finger entwined<br>in his hair.<br>“这是有蛇鲨栖息的地方！”,敲钟人让船队小心地着陆,<br>用他缠绕在头发上的手指 ,支撑每个站在潮边的船员。<br>“Just the place for a Snark! I have said it twice: That alone should<br>encourage the crew. Just the place for a Snark! I have said it thrice: What i<br>tell you three times is true.”<br>“这是有蛇鲨栖息的地方！这是我已经说的第二次了：凭这件事就可以激励你们奋勇向前。<br> 这是有蛇鲨栖息的地方！这是我已经说的第三次了：我告诉你们三次的话必定是真实的。”<br>The crew was complete: it included a Boots<br>— A maker of Bonnets andHoods<br>— A Barrister, brought to arrange their disputes<br>— And a Broker, tovalue their goods.<br>这是一个完整的船队：一个织出衣着的擦靴人。<br>一位解决纠纷的律师, 一位估价商品的经纪人。<br>A Billiard-maker, whose skill was immense, Might perhaps have wonmore than his share—<br>But a Banker, engaged at enormous expense, Had the whole of their cash in his care.<br>一个台球技术高超的记分员, 赢的钱可能比他的工资还高。<br>但是船上的银行家拿了船员的所有现金去做了一次小投资。<br>There was also a Beaver,<br>,that paced on the deck, Or would sit makinglace in the bow:<br>And had often (the Bellman said) saved them from wreck,<br>Though none of the sailors knew how.<br> 这里还有一只海狸，<br>他终日在甲板上踱步, 或者在甲板上绣花边：<br>好几次（敲钟人说的）将船员从落水中拯救。<br>尽管所有人都认为啊, 那是单单是在瞎胡扯。<br>There was one who was famed for the number of things He forgot<br>when he entered the ship: His umbrella, his watch, all his jewels and rings,<br>And the clothes he had bought for the trip.<br>还有一个因为总是忘记东西而出名的人：<br>他的伞,他的手表, 他的珠宝与戒指,<br>还有衣服都是为了,此次航行而购买。<br>He had forty-two boxes, all carefully packed, With his name painted<br>clearly on each: But, since he omitted to mention the fact, They were all<br>left behind on the beach.<br>他有箱子四十二,精致地包装每一个,<br>他将名字画其上,某一日却不再宣扬,<br>只因想起一件事,箱子被忘在海岸上。<br>The loss of his clothes hardly mattered, because He had seven coats on<br>when he came, With three pairs of boots—but the worst of it was, He had<br>wholly forgotten his name.<br>他那些丢了的衣服没什么大不了,只是因为来时<br>身穿七件外套,脚踩三双靴子<br>—但这并非最糟糕的事,他遗忘了自己的全部名字。<br>He would answer to “Hi!” or to any loud cry, Such as “Fry me!” or<br>“Fritter my wig!” To “What-you-may-call-um!” or “What-was-his-name!”<br>But especially “Thing-um-a-jig!”<br>他会大声的说出’你好！’,或着无所意义的叫喊,<br>“去用黄油煎了我！将我的假发切碎！”<br>“你可以将它~~称之为———嗯！”<br>“他的—名字—是————什————么！”<br>“那东西—嗯——是一支——吉格舞蹈！”<br>While, for those who preferred a more forcible word, He had different<br>names from these: His intimate friends called him “Candle-ends,” And his<br>enemies “Toasted-cheese.”<br>然而,对于那些更喜欢具有力度的词的人来说,<br>他有不同的名字：<br>他的亲友戏弄他为“蜡烛的残端”,他的仇人嘲笑他为“烧糊的奶酪”。<br>“His form in ungainly—his intellect small—“ (So the Bellman would<br>often remark) “But his courage is perfect! And that, after all, Is the thing<br>that one needs with a Snark.”<br>“他的四肢发达—他的头脑简单”<br>（所以敲钟人经常会备注）<br>“但他最亮眼的地方是勇气”“与蛇鲨战斗不需深谋远虑！要的只是直面恐惧的决心！”<br>He would joke with hyenas, returning their stare With an impudent<br>wag of the head: And he once went a walk, paw-in-paw, with a bear, “Just<br>to keep up its spirits,” he said.<br>他和鬣狗开玩笑，用不敬回击它的凝视，摇头晃脑使它愤怒。<br>某次啊，他与棕熊散步，爪子拉着爪子。<br>仅仅是为了“让它重振精神。”<br>He came as a Baker: but owned, when too late— And it drove the poor<br>Bellman half-mad— He could only bake Bridecake—for which, I may state,<br>No materials were to be had.<br>他来自此地有目的，想当一位面包师，<br>承认目的早已太晚，敲钟人要被气疯。<br>而他只会烘烤喜饼，而我早就已确信，<br>烘烤喜饼时根本没有材料会被使用！<br>The last of the crew needs especial remark, Though he looked an<br>incredible dunce: He had just one idea—but, that one being “Snark,” The<br>good Bellman engaged him at once.<br>最后的船员需特别关注，看着是个不可思议的蠢蛋：<br>用尽毕生的他明白一事，而那正好就是“蛇鲨”本体，<br>所以，敲钟人就简单地让他入队了。<br>He came as a Butcher: but gravely declared, When the ship had been<br>sailing a week, He could only kill Beavers. The Bellman looked scared,<br>And was almost too frightened to speak:<br>他来此地只为一事，去当屠夫宰杀动物：但他已经郑重声明，<br>船只航行一周之后，屠刀仅会挥向海狸，敲钟人对此很惊恐。<br>But at length he explained, in a tremulous tone, There was only one<br>Beaver on board; And that was a tame one he had of his own, Whose death<br>would be deeply deplored.<br>但到最后他解释道，尽管语调有些颤抖，<br>船上只有一只海狸；自己养的温顺海狸，<br>如果它真的死去了，会令大家深感遗憾。<br>The Beaver, who happened to hear the remark, Protested, with tears in<br>its eyes, That not even the rapture of hunting the Snark Could atone for<br>that dismal surprise!<br>海狸啊，碰巧听闻这件事，流着泪水来抗议，<br>它认为，成功捕到蛇鲨的喜悦也不可能弥补这令人痛心的意外！<br>It strongly advised that the Butcher should be Conveyed in a separate<br>ship: But the Bellman declared that would never agree With the plans he<br>had made for the trip:<br>海狸强烈地建议，让屠夫另乘他船，<br>但敲钟人却宣称，不改变乘船计划。<br>Navigation was always a difficult art, Though with only one ship and<br>one bell: And he feared he must really decline, for his part, Undertaking<br>another as well.<br>领船是件困难事，尽管只一船一钟，却担心船只安全，<br>就他自己而言，另一件事也一样令人烦恼。<br>The Beaver’s best course was, no doubt, to procure A second-hand<br>dagger-proof coat— So the Baker advised it— and next, to insure Its life in<br>some Office of note:<br>海狸现在面对着最大的危机，决定去买二手便宜防刺背心。<br>面包师有高见，觉得这太丢人现眼。<br>“想要省钱又安全，就要去买份保险”<br>This the Banker suggested, and offered for hire (On moderate terms),<br>or for sale, Two excellent Policies, one Against Fire, And one Against<br>Damage From Hail.<br>银行家突然现身，推荐海狸两份好保单。<br>无论租债或出售，条件全部都及其优惠，<br>“你的毛多怕火，就该买火险，<br> 海狸活在北极，理应买冰险”<br>Yet still, ever after that sorrowful day, Whenever the Butcher was by,<br>The Beaver kept looking the opposite way, And appeared unaccountably<br>shy<br>此后啊，在那个让海狸伤心欲绝的日子后，<br>每当屠夫经过它旁，它总会躲开目光，看起来十分害羞。</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
          <category> 蛇鲨狩猎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蛇鲨狩猎-前言</title>
      <link href="/2022/12/09/2022-12-9%E8%9B%87%E9%B2%A8%E7%8B%A9%E7%8C%8E/"/>
      <url>/2022/12/09/2022-12-9%E8%9B%87%E9%B2%A8%E7%8B%A9%E7%8C%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Hunting-of-The-Snark"><a href="#The-Hunting-of-The-Snark" class="headerlink" title="The Hunting of The Snark"></a>The Hunting of The Snark</h2><p>PREFACE<br>前言:<br>If-and the thing is wildly possible-the charge of writing nonsense were<br>ever brought against the author of this brief but instructive poem, it would<br>be based, I feel convinced.<br>我坚信不移，我的这首诗集是极有可能会被某些人以写废话的罪名为证据，用来指控带来这篇简单但及富教育意义诗集的作者.<br>“Then the bowsprit got mixed with the rudder sometimes.”<br>“后来啊船首斜桅有时会和船舵混搅在一起”<br>In view of this painful possibility, I will not (as I might) appeal<br>鉴于有这种令人感到不愉快的可能性，我不会（我如此想到）上诉.<br>indignantly to my other writings as a proof that I am incapable of such a<br>deed: I will not (as I might) point to the strong moral purpose of this poem<br>itself, to the arithmetical principles so cautiously inculcated in it, or to its<br>noble teachings in Natural History—I will take the more prosaic course of<br>simply explaining how it happened.<br>让我愤怒的是，我的其他作品犹如破案证据，证实我无法这样做：我不会指出这首诗所指向的难以辩驳的道德目的，或是其中<br>所灌输的数学原理，亦或者是其所蕴含的自然历史中的崇高交易—我仅仅会选择更平凡的课程，简单地解释一下它是如何产生<br>的.<br>The Bellman, who was almost morbidly sensitive about appearances,<br>used to have the bowsprit unshipped once or twice a week to be<br>revarnished, and it more than once happened, when the time came for<br>replacing it, that no one on board could remember which end of the ship it<br>belonged to. They knew it was not of the slightest use to appeal to the<br>Bellman about it— he would only refer to his Naval Code, and read out in<br>pathetic tones Admiralty Instructions which none of them had ever been<br>able to understand— so it generally ended in its being fastened on, anyhow,<br>across the rudder. The helmsman used to stand by with tears in his eyes;<br>he knew it was all wrong, but alas! Rule 42 of the Code, “No one shall<br>speak to the Man at the Helm,” had been completed by the Bellman<br>himself with the words “and the Man at the Helm shall speak to no one.”<br>So remonstrance was impossible, and no steering could be done till the<br>next varnishing day. During these bewildering intervals the ship usually<br>sailed backwards.<br>有个病态的船长,每周都把斜桅卸。<br>反反复复去磨光,不仅一次又两次。<br>到了最后的日子,已经无人识前后。<br>抱怨此事没用处,船长是个二愣子。<br>盲目遵从自己的守则,念出无人理解的指令。<br>水手们啊，把斜桅杆固,船员含着泪站一旁。<br>知其一切都错误,但《海军守则》42,<br>“任何人不与舵手交谈。”<br>船长以自己方式叙,<br>“舵手也不与任何人交谈。”<br>直到下一个磨光日，此日前不会有抱怨。<br>于这困惑的时间里，船只通常向后航行。<br>As this poem is to some extent connected with the lay of the<br>Jabberwock, let me take this opportunity of answering a question that has<br>often been asked me, how to pronounce “slithy toves.” The “i” in “slithy”<br>is long, as in “writhe”; and “toves” is pronounced so as to rhyme with<br>“groves.” Again, the first “o” in “borogoves” is pronounced like the “o” in<br>“borrow.” I have heard people try to give it the sound of the “o” in “worry.<br>Such is Human Perversity.<br>因为这首诗在某种程度上与《贾巴沃克》有一定的联系，让我来借此机会回答一个经常被问到的问题，”slithy toves.”<br>如何发音，“i”在“slithy”中发长音，如在“wrethe”.”toves”的发音和”groves”有所押韵.再说“borogoves”中第一个<br>“o”的发音和”borrow”中的“o”的发音相似.我曾听说有人尝试过用“worry”中的“o”来表示，这就是人类的自以为是的地方.<br>This also seems a fitting occasion to notice the other hard works in<br>that poem. Humpty-Dumpty’s theory, of two meanings packed into one<br>word like a portmanteau, seems to me the right explanation for all.<br>For instance, take the two words “fuming” and “furious.” Make up<br>your mind that you will say both words, but leave it unsettled which you<br>will say first. Now open your mouth and speak. If your thoughts incline<br>ever so little towards “fuming,” you will say “fuming-furious;” if they turn,<br>by even a hair’s breadth, towards “furious,” you will say “furious-fuming;”<br>but if you have the rarest of gifts, a perfectly balanced mind, you will say<br>“frumious.”<br>这也似乎是一个合适的时机去注意到这首诗中其他的难解之处.如同Humpty-Dumpty一样，把两个不同意思的单词组合成一<br>个词，就像一个塞满物品的手提箱。对我来说，这就是正确的解释。例如，用“恼火（fuming）”和“盛怒（furious）”这<br>两个词.说这两个词之前先让你的头脑想好，但不要确认你要说的第一个词.现在张开你的嘴巴，然后说出它.如果在你的认知<br>里 “fuming”的优先级很低，你就会说出”fuming-furious;”.细微地颠倒过来，如果”furious”优先级很低，你就会说<br>出 “furious-fuming;”但是如果你有着极高的天赋，有一个完美平衡的头脑，你就会说出”frumious”.<br>Supposing that, when Pistol uttered the well-known words—<br>“Under which king, Bezonian? Speak or die!”<br>Justice Shallow had felt certain that it was either William or Richard,<br>but had not been able to settle which, so that he could not possibly say<br>either name before the other, can it be doubted that, rather than die, he<br>would have gasped out “Rilchiam!”<br>假设此时，当Pistol说出那个众所周知的话语—“是哪位国王指示你的？恶棍，要么说出名字，要么就去死！”Shallow审判<br>官已经确定，不是威廉就是理查德，但是一直未能确定是哪一个，所以他不可能说出有嫌疑的人以外的另一个人，对于恶棍来<br>说比起死亡，他更会气喘吁吁地说出 “Rilchiam!”</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
          <category> 蛇鲨狩猎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蛇鲨狩猎-序</title>
      <link href="/2022/12/08/2022-12-8-%E8%9B%87%E9%B2%A8%E7%8B%A9%E7%8C%8E/"/>
      <url>/2022/12/08/2022-12-8-%E8%9B%87%E9%B2%A8%E7%8B%A9%E7%8C%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Hunting-of-The-Snark"><a href="#The-Hunting-of-The-Snark" class="headerlink" title="The Hunting of The Snark"></a>The Hunting of The Snark</h2><p>蛇鲨狩猎<br>序<br>Inscribed to a dear Child:<br>写给我亲爱的少女：<br>in memory of golden summer hours and whispers of a summer sea.<br> 为了纪念夏日黄金时光与午后海洋低语<br>Girt with a boyish garb for boyish task, Eager she wields her spade: yet loves as well<br> 身着男孩子气的装束，她急切地挥舞着铁锹，想要完成儿童的作业：对待爱也如此<br>Rest on a friendly knee, intent to ask<br> 倚靠在其小巧膝盖上，她热切地询问我<br>The tale he loves to tell.<br> 最喜爱的那则故事<br>Rude spirits of the seething outer strife, Unmeet to read her pure and simple spright,<br> 于外方的斗争沸腾着野蛮的灵魂也无法读懂她洁白纯粹的心境<br>Deem, if you list, such hours a waste of life,<br> 如果你认为那种时光是对于生命的浪费<br>Empty of all delight!<br> （我只能说）那才是毫无乐趣可言<br>Chat on, sweet Maid, and rescue from annoy<br> 闲谈之中，少女甜美的笑颜将我于烦恼之中拯救<br>Hearts that by wiser talk are unbeguiled. Ah, happy he who owns that tenderest joy,<br> 使用心智交流的心不可欺骗，Ah，拥有幼稚乐趣的人享受幸福<br>The heart-love of a child!<br> 对最爱的女孩需要全心全意的爱意<br>Away, fond thoughts, and vex my soul no more!<br> 多余的想法啊，请从我的脑子里滚出去，不要再搅浑我的心灵！<br>Work claims my wakeful nights, my busy days—Albeit bright memories of that sunlit shore<br> 无趣的工作让我难眠，给予我无法抽出时间的惩罚——尽管如此那黄金海岸的美好回忆仍旧萦绕<br>Yet haunt my dreaming gaze!<br> 萦绕于我梦中的视线前方！</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
          <category> 蛇鲨狩猎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
